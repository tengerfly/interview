神三元JS篇

# JavaScript 内存机制之问-- 数据是如何存储的？

 基本数据类型存储在栈中，引用数据类型存储在堆中。还要补充的是，闭包也是存储在堆中的，因为闭包执行完之后，变量没有被回收。

 引用类型，引用地址是存储在栈中的。

栈除了存储基本数据类型，还要存储执行上下文。

栈存储的数据相对量小的数据，堆主要用来存储大数据。
思考：假如说有一个字符串长度很长，是存储在栈中还是堆中？

`栈主要是通过ESP指针根据当前执行状态入栈和出栈对数据进行存储和垃圾回收的` 这是我个人的理解，有待商榷

为什么不把所有的数据都存放在栈中？

JavaScript通过栈来管理上下文，如果把所有数据都放在栈里，执行上下文的效率会收到很大的影响，进而影响整个程序的执行效率。(我想的一种情况，不知道恰当不恰当：假如有a,b两个函数，函数a执行完毕之后，需要执行b，如果把所有的变量存储在栈中，恰好函数a, b的执行栈之间有一大堆变量，要执行b的时候得先把这些变量一个一个的清除掉，之后才能去执行b, b执行的效率大大降级了，如果没有这些大的变量，a 执行完之后，即可很快执行b，运行效率提升了 )

# V8引擎如何进行垃圾内存的回收？

之前对垃圾回收的理解:

>ESP指针是通过指针的改变对栈垃圾回收的。堆内存有自己的垃圾回收机制。现在我们说的垃圾回收主要是针对堆的。堆的垃圾回收机制分为新生代和老生代，新生代分为两个空间，from空间和to空间，to空间是空着的，在垃圾回收的时候，先遍历，标记用到的变量放到to空间，然后清除from空间，to 空间和from空间对换，垃圾回收结束。老生代的话用的是标记清除法，先对空间里的变量进行遍历，用到的进行标记，然后没有用到的进行回收。这会造成空间碎片化，使用算法对空间进行整理。

V8的内存限制：64位系统下1.5G

## 李兵在浏览器的工作原理与实践中讲的垃圾回收

栈的垃圾回收

js在执行的过程中，会有一个记录当前执行状态的指针(ESP), 栈中的垃圾回收，就是通过ESP指针的向下移动来销毁该函数保存在栈中的执行上下文。

堆的垃圾回收

`代际假说`，这是垃圾回收领域中一个重要的术语，垃圾回收的策略都是建立在`代际假说`的基础之上的。

>`代际假说`有两个特点：
> - 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问
> 不死的对象，存活的越久

在V8中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代存放的是生存时间久的对象

>新生代区通常只支持1~8M的容量
>副垃圾回收器，主要负责新生代的垃圾回收
>主垃圾回收器，主要负责老生代的垃圾回收

不论是什么类型的垃圾回收器，它们都有一套共同的执行流程。

- 标记空间中活动对象和非活动对象。活动对象就是指还在使用的对象，非活动对象就是可以进行垃圾回收的对象
- 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象
- 内存整理。 